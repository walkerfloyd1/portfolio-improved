{"ast":null,"code":"// Copyright 2012 Joyent, Inc.  All rights reserved.\nvar assert = require('assert-plus');\n\nvar crypto = require('crypto');\n\nvar asn1 = require('asn1');\n\nvar ctype = require('ctype'); ///--- Helpers\n\n\nfunction readNext(buffer, offset) {\n  var len = ctype.ruint32(buffer, 'big', offset);\n  offset += 4;\n  var newOffset = offset + len;\n  return {\n    data: buffer.slice(offset, newOffset),\n    offset: newOffset\n  };\n}\n\nfunction writeInt(writer, buffer) {\n  writer.writeByte(0x02); // ASN1.Integer\n\n  writer.writeLength(buffer.length);\n\n  for (var i = 0; i < buffer.length; i++) writer.writeByte(buffer[i]);\n\n  return writer;\n}\n\nfunction rsaToPEM(key) {\n  var buffer;\n  var der;\n  var exponent;\n  var i;\n  var modulus;\n  var newKey = '';\n  var offset = 0;\n  var type;\n  var tmp;\n\n  try {\n    buffer = new Buffer(key.split(' ')[1], 'base64');\n    tmp = readNext(buffer, offset);\n    type = tmp.data.toString();\n    offset = tmp.offset;\n    if (type !== 'ssh-rsa') throw new Error('Invalid ssh key type: ' + type);\n    tmp = readNext(buffer, offset);\n    exponent = tmp.data;\n    offset = tmp.offset;\n    tmp = readNext(buffer, offset);\n    modulus = tmp.data;\n  } catch (e) {\n    throw new Error('Invalid ssh key: ' + key);\n  } // DER is a subset of BER\n\n\n  der = new asn1.BerWriter();\n  der.startSequence();\n  der.startSequence();\n  der.writeOID('1.2.840.113549.1.1.1');\n  der.writeNull();\n  der.endSequence();\n  der.startSequence(0x03); // bit string\n\n  der.writeByte(0x00); // Actual key\n\n  der.startSequence();\n  writeInt(der, modulus);\n  writeInt(der, exponent);\n  der.endSequence(); // bit string\n\n  der.endSequence();\n  der.endSequence();\n  tmp = der.buffer.toString('base64');\n\n  for (i = 0; i < tmp.length; i++) {\n    if (i % 64 === 0) newKey += '\\n';\n    newKey += tmp.charAt(i);\n  }\n\n  if (!/\\\\n$/.test(newKey)) newKey += '\\n';\n  return '-----BEGIN PUBLIC KEY-----' + newKey + '-----END PUBLIC KEY-----\\n';\n}\n\nfunction dsaToPEM(key) {\n  var buffer;\n  var offset = 0;\n  var tmp;\n  var der;\n  var newKey = '';\n  var type;\n  var p;\n  var q;\n  var g;\n  var y;\n\n  try {\n    buffer = new Buffer(key.split(' ')[1], 'base64');\n    tmp = readNext(buffer, offset);\n    type = tmp.data.toString();\n    offset = tmp.offset;\n    /* JSSTYLED */\n\n    if (!/^ssh-ds[as].*/.test(type)) throw new Error('Invalid ssh key type: ' + type);\n    tmp = readNext(buffer, offset);\n    p = tmp.data;\n    offset = tmp.offset;\n    tmp = readNext(buffer, offset);\n    q = tmp.data;\n    offset = tmp.offset;\n    tmp = readNext(buffer, offset);\n    g = tmp.data;\n    offset = tmp.offset;\n    tmp = readNext(buffer, offset);\n    y = tmp.data;\n  } catch (e) {\n    console.log(e.stack);\n    throw new Error('Invalid ssh key: ' + key);\n  } // DER is a subset of BER\n\n\n  der = new asn1.BerWriter();\n  der.startSequence();\n  der.startSequence();\n  der.writeOID('1.2.840.10040.4.1');\n  der.startSequence();\n  writeInt(der, p);\n  writeInt(der, q);\n  writeInt(der, g);\n  der.endSequence();\n  der.endSequence();\n  der.startSequence(0x03); // bit string\n\n  der.writeByte(0x00);\n  writeInt(der, y);\n  der.endSequence();\n  der.endSequence();\n  tmp = der.buffer.toString('base64');\n\n  for (var i = 0; i < tmp.length; i++) {\n    if (i % 64 === 0) newKey += '\\n';\n    newKey += tmp.charAt(i);\n  }\n\n  if (!/\\\\n$/.test(newKey)) newKey += '\\n';\n  return '-----BEGIN PUBLIC KEY-----' + newKey + '-----END PUBLIC KEY-----\\n';\n} ///--- API\n\n\nmodule.exports = {\n  /**\n   * Converts an OpenSSH public key (rsa only) to a PKCS#8 PEM file.\n   *\n   * The intent of this module is to interoperate with OpenSSL only,\n   * specifically the node crypto module's `verify` method.\n   *\n   * @param {String} key an OpenSSH public key.\n   * @return {String} PEM encoded form of the RSA public key.\n   * @throws {TypeError} on bad input.\n   * @throws {Error} on invalid ssh key formatted data.\n   */\n  sshKeyToPEM: function sshKeyToPEM(key) {\n    assert.string(key, 'ssh_key');\n    /* JSSTYLED */\n\n    if (/^ssh-rsa.*/.test(key)) return rsaToPEM(key);\n    /* JSSTYLED */\n\n    if (/^ssh-ds[as].*/.test(key)) return dsaToPEM(key);\n    throw new Error('Only RSA and DSA public keys are allowed');\n  },\n\n  /**\n   * Generates an OpenSSH fingerprint from an ssh public key.\n   *\n   * @param {String} key an OpenSSH public key.\n   * @return {String} key fingerprint.\n   * @throws {TypeError} on bad input.\n   * @throws {Error} if what you passed doesn't look like an ssh public key.\n   */\n  fingerprint: function fingerprint(key) {\n    assert.string(key, 'ssh_key');\n    var pieces = key.split(' ');\n    if (!pieces || !pieces.length || pieces.length < 2) throw new Error('invalid ssh key');\n    var data = new Buffer(pieces[1], 'base64');\n    var hash = crypto.createHash('md5');\n    hash.update(data);\n    var digest = hash.digest('hex');\n    var fp = '';\n\n    for (var i = 0; i < digest.length; i++) {\n      if (i && i % 2 === 0) fp += ':';\n      fp += digest[i];\n    }\n\n    return fp;\n  },\n\n  /**\n   * Converts a PKGCS#8 PEM file to an OpenSSH public key (rsa)\n   *\n   * The reverse of the above function.\n   */\n  pemToRsaSSHKey: function pemToRsaSSHKey(pem, comment) {\n    assert.equal('string', typeof pem, 'typeof pem'); // chop off the BEGIN PUBLIC KEY and END PUBLIC KEY portion\n\n    var cleaned = pem.split('\\n').slice(1, -2).join('');\n    var buf = new Buffer(cleaned, 'base64');\n    var der = new asn1.BerReader(buf);\n    der.readSequence();\n    der.readSequence();\n    var oid = der.readOID();\n    assert.equal(oid, '1.2.840.113549.1.1.1', 'pem not in RSA format'); // Null -- XXX this probably isn't good practice\n\n    der.readByte();\n    der.readByte(); // bit string sequence\n\n    der.readSequence(0x03);\n    der.readByte();\n    der.readSequence(); // modulus\n\n    assert.equal(der.peek(), asn1.Ber.Integer, 'modulus not an integer');\n    der._offset = der.readLength(der.offset + 1);\n\n    var modulus = der._buf.slice(der.offset, der.offset + der.length);\n\n    der._offset += der.length; // exponent\n\n    assert.equal(der.peek(), asn1.Ber.Integer, 'exponent not an integer');\n    der._offset = der.readLength(der.offset + 1);\n\n    var exponent = der._buf.slice(der.offset, der.offset + der.length);\n\n    der._offset += der.length; // now, make the key\n\n    var type = new Buffer('ssh-rsa');\n    var buffer = new Buffer(4 + type.length + 4 + modulus.length + 4 + exponent.length);\n    var i = 0;\n    buffer.writeUInt32BE(type.length, i);\n    i += 4;\n    type.copy(buffer, i);\n    i += type.length;\n    buffer.writeUInt32BE(exponent.length, i);\n    i += 4;\n    exponent.copy(buffer, i);\n    i += exponent.length;\n    buffer.writeUInt32BE(modulus.length, i);\n    i += 4;\n    modulus.copy(buffer, i);\n    i += modulus.length;\n    var s = type.toString() + ' ' + buffer.toString('base64') + ' ' + (comment || '');\n    return s;\n  }\n};","map":null,"metadata":{},"sourceType":"script"}