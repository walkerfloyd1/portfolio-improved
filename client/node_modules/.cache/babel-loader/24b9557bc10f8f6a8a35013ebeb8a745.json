{"ast":null,"code":"// Copyright (c) 2012, Mark Cavage. All rights reserved.\nvar assert = require('assert');\n\nvar Stream = require('stream').Stream;\n\nvar util = require('util'); ///--- Globals\n\n\nvar NDEBUG = process.env.NODE_NDEBUG || false;\nvar UUID_REGEXP = /^[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}$/; ///--- Messages\n\nvar ARRAY_TYPE_REQUIRED = '%s ([%s]) required';\nvar TYPE_REQUIRED = '%s (%s) is required'; ///--- Internal\n\nfunction capitalize(str) {\n  return str.charAt(0).toUpperCase() + str.slice(1);\n}\n\nfunction uncapitalize(str) {\n  return str.charAt(0).toLowerCase() + str.slice(1);\n}\n\nfunction _() {\n  return util.format.apply(util, arguments);\n}\n\nfunction _assert(arg, type, name, stackFunc) {\n  if (!NDEBUG) {\n    name = name || type;\n    stackFunc = stackFunc || _assert.caller;\n    var t = typeof arg;\n\n    if (t !== type) {\n      throw new assert.AssertionError({\n        message: _(TYPE_REQUIRED, name, type),\n        actual: t,\n        expected: type,\n        operator: '===',\n        stackStartFunction: stackFunc\n      });\n    }\n  }\n}\n\nfunction _instanceof(arg, type, name, stackFunc) {\n  if (!NDEBUG) {\n    name = name || type;\n    stackFunc = stackFunc || _instanceof.caller;\n\n    if (!(arg instanceof type)) {\n      throw new assert.AssertionError({\n        message: _(TYPE_REQUIRED, name, type.name),\n        actual: _getClass(arg),\n        expected: type.name,\n        operator: 'instanceof',\n        stackStartFunction: stackFunc\n      });\n    }\n  }\n}\n\nfunction _getClass(object) {\n  return Object.prototype.toString.call(object).slice(8, -1);\n}\n\n; ///--- API\n\nfunction array(arr, type, name) {\n  if (!NDEBUG) {\n    name = name || type;\n\n    if (!Array.isArray(arr)) {\n      throw new assert.AssertionError({\n        message: _(ARRAY_TYPE_REQUIRED, name, type),\n        actual: typeof arr,\n        expected: 'array',\n        operator: 'Array.isArray',\n        stackStartFunction: array.caller\n      });\n    }\n\n    for (var i = 0; i < arr.length; i++) {\n      _assert(arr[i], type, name, array);\n    }\n  }\n}\n\nfunction bool(arg, name) {\n  _assert(arg, 'boolean', name, bool);\n}\n\nfunction buffer(arg, name) {\n  if (!Buffer.isBuffer(arg)) {\n    throw new assert.AssertionError({\n      message: _(TYPE_REQUIRED, name || '', 'Buffer'),\n      actual: typeof arg,\n      expected: 'buffer',\n      operator: 'Buffer.isBuffer',\n      stackStartFunction: buffer\n    });\n  }\n}\n\nfunction func(arg, name) {\n  _assert(arg, 'function', name);\n}\n\nfunction number(arg, name) {\n  _assert(arg, 'number', name);\n\n  if (!NDEBUG && (isNaN(arg) || !isFinite(arg))) {\n    throw new assert.AssertionError({\n      message: _(TYPE_REQUIRED, name, 'number'),\n      actual: arg,\n      expected: 'number',\n      operator: 'isNaN',\n      stackStartFunction: number\n    });\n  }\n}\n\nfunction object(arg, name) {\n  _assert(arg, 'object', name);\n}\n\nfunction stream(arg, name) {\n  _instanceof(arg, Stream, name);\n}\n\nfunction date(arg, name) {\n  _instanceof(arg, Date, name);\n}\n\nfunction regexp(arg, name) {\n  _instanceof(arg, RegExp, name);\n}\n\nfunction string(arg, name) {\n  _assert(arg, 'string', name);\n}\n\nfunction uuid(arg, name) {\n  string(arg, name);\n\n  if (!NDEBUG && !UUID_REGEXP.test(arg)) {\n    throw new assert.AssertionError({\n      message: _(TYPE_REQUIRED, name, 'uuid'),\n      actual: 'string',\n      expected: 'uuid',\n      operator: 'test',\n      stackStartFunction: uuid\n    });\n  }\n} ///--- Exports\n\n\nmodule.exports = {\n  bool: bool,\n  buffer: buffer,\n  date: date,\n  func: func,\n  number: number,\n  object: object,\n  regexp: regexp,\n  stream: stream,\n  string: string,\n  uuid: uuid\n};\nObject.keys(module.exports).forEach(function (k) {\n  if (k === 'buffer') return;\n  var name = 'arrayOf' + capitalize(k);\n  if (k === 'bool') k = 'boolean';\n  if (k === 'func') k = 'function';\n\n  module.exports[name] = function (arg, name) {\n    array(arg, k, name);\n  };\n});\nObject.keys(module.exports).forEach(function (k) {\n  var _name = 'optional' + capitalize(k);\n\n  var s = uncapitalize(k.replace('arrayOf', ''));\n  if (s === 'bool') s = 'boolean';\n  if (s === 'func') s = 'function';\n\n  if (k.indexOf('arrayOf') !== -1) {\n    module.exports[_name] = function (arg, name) {\n      if (!NDEBUG && arg !== undefined) {\n        array(arg, s, name);\n      }\n    };\n  } else {\n    module.exports[_name] = function (arg, name) {\n      if (!NDEBUG && arg !== undefined) {\n        _assert(arg, s, name);\n      }\n    };\n  }\n}); // Reexport built-in assertions\n\nObject.keys(assert).forEach(function (k) {\n  if (k === 'AssertionError') {\n    module.exports[k] = assert[k];\n    return;\n  }\n\n  module.exports[k] = function () {\n    if (!NDEBUG) {\n      assert[k].apply(assert[k], arguments);\n    }\n  };\n});","map":null,"metadata":{},"sourceType":"script"}