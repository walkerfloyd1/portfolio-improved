{"ast":null,"code":"/*\n * rm - Feb 2011\n * ctype.js\n *\n * This module provides a simple abstraction towards reading and writing\n * different types of binary data. It is designed to use ctio.js and provide a\n * richer and more expressive API on top of it.\n *\n * By default we support the following as built in basic types:\n *\tint8_t\n *\tint16_t\n *\tint32_t\n *\tuint8_t\n *\tuint16_t\n *\tuint32_t\n *\tuint64_t\n *\tfloat\n *\tdouble\n *\tchar\n *\tchar[]\n *\n * Each type is returned as a Number, with the exception of char and char[]\n * which are returned as Node Buffers. A char is considered a uint8_t.\n *\n * Requests to read and write data are specified as an array of JSON objects.\n * This is also the same way that one declares structs. Even if just a single\n * value is requested, it must be done as a struct. The array order determines\n * the order that we try and read values. Each entry has the following format\n * with values marked with a * being optional.\n *\n * { key: { type: /type/, value*: /value/, offset*: /offset/ }\n *\n * If offset is defined, we lseek(offset, SEEK_SET) before reading the next\n * value. Value is defined when we're writing out data, otherwise it's ignored.\n *\n */\nvar mod_ctf = require('./ctf.js');\n\nvar mod_ctio = require('./ctio.js');\n\nvar mod_assert = require('assert');\n/*\n * This is the set of basic types that we support.\n *\n *\tread\t\tThe function to call to read in a value from a buffer\n *\n *\twrite\t\tThe function to call to write a value to a buffer\n *\n */\n\n\nvar deftypes = {\n  'uint8_t': {\n    read: ctReadUint8,\n    write: ctWriteUint8\n  },\n  'uint16_t': {\n    read: ctReadUint16,\n    write: ctWriteUint16\n  },\n  'uint32_t': {\n    read: ctReadUint32,\n    write: ctWriteUint32\n  },\n  'uint64_t': {\n    read: ctReadUint64,\n    write: ctWriteUint64\n  },\n  'int8_t': {\n    read: ctReadSint8,\n    write: ctWriteSint8\n  },\n  'int16_t': {\n    read: ctReadSint16,\n    write: ctWriteSint16\n  },\n  'int32_t': {\n    read: ctReadSint32,\n    write: ctWriteSint32\n  },\n  'int64_t': {\n    read: ctReadSint64,\n    write: ctWriteSint64\n  },\n  'float': {\n    read: ctReadFloat,\n    write: ctWriteFloat\n  },\n  'double': {\n    read: ctReadDouble,\n    write: ctWriteDouble\n  },\n  'char': {\n    read: ctReadChar,\n    write: ctWriteChar\n  },\n  'char[]': {\n    read: ctReadCharArray,\n    write: ctWriteCharArray\n  }\n};\n/*\n * The following are wrappers around the CType IO low level API. They encode\n * knowledge about the size and return something in the expected format.\n */\n\nfunction ctReadUint8(endian, buffer, offset) {\n  var val = mod_ctio.ruint8(buffer, endian, offset);\n  return {\n    value: val,\n    size: 1\n  };\n}\n\nfunction ctReadUint16(endian, buffer, offset) {\n  var val = mod_ctio.ruint16(buffer, endian, offset);\n  return {\n    value: val,\n    size: 2\n  };\n}\n\nfunction ctReadUint32(endian, buffer, offset) {\n  var val = mod_ctio.ruint32(buffer, endian, offset);\n  return {\n    value: val,\n    size: 4\n  };\n}\n\nfunction ctReadUint64(endian, buffer, offset) {\n  var val = mod_ctio.ruint64(buffer, endian, offset);\n  return {\n    value: val,\n    size: 8\n  };\n}\n\nfunction ctReadSint8(endian, buffer, offset) {\n  var val = mod_ctio.rsint8(buffer, endian, offset);\n  return {\n    value: val,\n    size: 1\n  };\n}\n\nfunction ctReadSint16(endian, buffer, offset) {\n  var val = mod_ctio.rsint16(buffer, endian, offset);\n  return {\n    value: val,\n    size: 2\n  };\n}\n\nfunction ctReadSint32(endian, buffer, offset) {\n  var val = mod_ctio.rsint32(buffer, endian, offset);\n  return {\n    value: val,\n    size: 4\n  };\n}\n\nfunction ctReadSint64(endian, buffer, offset) {\n  var val = mod_ctio.rsint64(buffer, endian, offset);\n  return {\n    value: val,\n    size: 8\n  };\n}\n\nfunction ctReadFloat(endian, buffer, offset) {\n  var val = mod_ctio.rfloat(buffer, endian, offset);\n  return {\n    value: val,\n    size: 4\n  };\n}\n\nfunction ctReadDouble(endian, buffer, offset) {\n  var val = mod_ctio.rdouble(buffer, endian, offset);\n  return {\n    value: val,\n    size: 8\n  };\n}\n/*\n * Reads a single character into a node buffer\n */\n\n\nfunction ctReadChar(endian, buffer, offset) {\n  var res = new Buffer(1);\n  res[0] = mod_ctio.ruint8(buffer, endian, offset);\n  return {\n    value: res,\n    size: 1\n  };\n}\n\nfunction ctReadCharArray(length, endian, buffer, offset) {\n  var ii;\n  var res = new Buffer(length);\n\n  for (ii = 0; ii < length; ii++) res[ii] = mod_ctio.ruint8(buffer, endian, offset + ii);\n\n  return {\n    value: res,\n    size: length\n  };\n}\n\nfunction ctWriteUint8(value, endian, buffer, offset) {\n  mod_ctio.wuint8(value, endian, buffer, offset);\n  return 1;\n}\n\nfunction ctWriteUint16(value, endian, buffer, offset) {\n  mod_ctio.wuint16(value, endian, buffer, offset);\n  return 2;\n}\n\nfunction ctWriteUint32(value, endian, buffer, offset) {\n  mod_ctio.wuint32(value, endian, buffer, offset);\n  return 4;\n}\n\nfunction ctWriteUint64(value, endian, buffer, offset) {\n  mod_ctio.wuint64(value, endian, buffer, offset);\n  return 8;\n}\n\nfunction ctWriteSint8(value, endian, buffer, offset) {\n  mod_ctio.wsint8(value, endian, buffer, offset);\n  return 1;\n}\n\nfunction ctWriteSint16(value, endian, buffer, offset) {\n  mod_ctio.wsint16(value, endian, buffer, offset);\n  return 2;\n}\n\nfunction ctWriteSint32(value, endian, buffer, offset) {\n  mod_ctio.wsint32(value, endian, buffer, offset);\n  return 4;\n}\n\nfunction ctWriteSint64(value, endian, buffer, offset) {\n  mod_ctio.wsint64(value, endian, buffer, offset);\n  return 8;\n}\n\nfunction ctWriteFloat(value, endian, buffer, offset) {\n  mod_ctio.wfloat(value, endian, buffer, offset);\n  return 4;\n}\n\nfunction ctWriteDouble(value, endian, buffer, offset) {\n  mod_ctio.wdouble(value, endian, buffer, offset);\n  return 8;\n}\n/*\n * Writes a single character into a node buffer\n */\n\n\nfunction ctWriteChar(value, endian, buffer, offset) {\n  if (!(value instanceof Buffer)) throw new Error('Input must be a buffer');\n  mod_ctio.ruint8(value[0], endian, buffer, offset);\n  return 1;\n}\n/*\n * We're going to write 0s into the buffer if the string is shorter than the\n * length of the array.\n */\n\n\nfunction ctWriteCharArray(value, length, endian, buffer, offset) {\n  var ii;\n  if (!(value instanceof Buffer)) throw new Error('Input must be a buffer');\n  if (value.length > length) throw new Error('value length greater than array length');\n\n  for (ii = 0; ii < value.length && ii < length; ii++) mod_ctio.wuint8(value[ii], endian, buffer, offset + ii);\n\n  for (; ii < length; ii++) mod_ctio.wuint8(0, endian, offset + ii);\n\n  return length;\n}\n/*\n * Each parser has their own set of types. We want to make sure that they each\n * get their own copy as they may need to modify it.\n */\n\n\nfunction ctGetBasicTypes() {\n  var ret = {};\n  var key;\n\n  for (key in deftypes) ret[key] = deftypes[key];\n\n  return ret;\n}\n/*\n * Given a string in the form of type[length] we want to split this into an\n * object that extracts that information. We want to note that we could possibly\n * have nested arrays so this should only check the furthest one. It may also be\n * the case that we have no [] pieces, in which case we just return the current\n * type.\n */\n\n\nfunction ctParseType(str) {\n  var begInd, endInd;\n  var type, len;\n  if (typeof str != 'string') throw new Error('type must be a Javascript string');\n  endInd = str.lastIndexOf(']');\n\n  if (endInd == -1) {\n    if (str.lastIndexOf('[') != -1) throw new Error('found invalid type with \\'[\\' but ' + 'no corresponding \\']\\'');\n    return {\n      type: str\n    };\n  }\n\n  begInd = str.lastIndexOf('[');\n  if (begInd == -1) throw new Error('found invalid type with \\']\\' but ' + 'no corresponding \\'[\\'');\n  if (begInd >= endInd) throw new Error('malformed type, \\']\\' appears before \\'[\\'');\n  type = str.substring(0, begInd);\n  len = str.substring(begInd + 1, endInd);\n  return {\n    type: type,\n    len: len\n  };\n}\n/*\n * Given a request validate that all of the fields for it are valid and make\n * sense. This includes verifying the following notions:\n *  - Each type requested is present in types\n *  - Only allow a name for a field to be specified once\n *  - If an array is specified, validate that the requested field exists and\n *    comes before it.\n *  - If fields is defined, check that each entry has the occurrence of field\n */\n\n\nfunction ctCheckReq(def, types, fields) {\n  var ii, jj;\n  var req, keys, key;\n  var found = {};\n  if (!(def instanceof Array)) throw new Error('definition is not an array');\n  if (def.length === 0) throw new Error('definition must have at least one element');\n\n  for (ii = 0; ii < def.length; ii++) {\n    req = def[ii];\n    if (!(req instanceof Object)) throw new Error('definition must be an array of' + 'objects');\n    keys = Object.keys(req);\n    if (keys.length != 1) throw new Error('definition entry must only have ' + 'one key');\n    if (keys[0] in found) throw new Error('Specified name already ' + 'specified: ' + keys[0]);\n    if (!('type' in req[keys[0]])) throw new Error('missing required type definition');\n    key = ctParseType(req[keys[0]]['type']);\n    /*\n     * We may have nested arrays, we need to check the validity of\n     * the types until the len field is undefined in key. However,\n     * each time len is defined we need to verify it is either an\n     * integer or corresponds to an already seen key.\n     */\n\n    while (key['len'] !== undefined) {\n      if (isNaN(parseInt(key['len'], 10))) {\n        if (!(key['len'] in found)) throw new Error('Given an array ' + 'length without a matching type');\n      }\n\n      key = ctParseType(key['type']);\n    }\n    /* Now we can validate if the type is valid */\n\n\n    if (!(key['type'] in types)) throw new Error('type not found or typdefed: ' + key['type']);\n    /* Check for any required fields */\n\n    if (fields !== undefined) {\n      for (jj = 0; jj < fields.length; jj++) {\n        if (!(fields[jj] in req[keys[0]])) throw new Error('Missing required ' + 'field: ' + fields[jj]);\n      }\n    }\n\n    found[keys[0]] = true;\n  }\n}\n/*\n * Create a new instance of the parser. Each parser has its own store of\n * typedefs and endianness. Conf is an object with the following required\n * values:\n *\n *\tendian\t\tEither 'big' or 'little' do determine the endianness we\n *\t\t\twant to read from or write to.\n *\n * And the following optional values:\n *\n * \tchar-type\tValid options here are uint8 and int8. If uint8 is\n * \t\t\tspecified this changes the default behavior of a single\n * \t\t\tchar from being a buffer of a single character to being\n * \t\t\ta uint8_t. If int8, it becomes an int8_t instead.\n */\n\n\nfunction CTypeParser(conf) {\n  if (!conf) throw new Error('missing required argument');\n  if (!('endian' in conf)) throw new Error('missing required endian value');\n  if (conf['endian'] != 'big' && conf['endian'] != 'little') throw new Error('Invalid endian type');\n  if ('char-type' in conf && conf['char-type'] != 'uint8' && conf['char-type'] != 'int8') throw new Error('invalid option for char-type: ' + conf['char-type']);\n  this.endian = conf['endian'];\n  this.types = ctGetBasicTypes();\n  /*\n   * There may be a more graceful way to do this, but this will have to\n   * serve.\n   */\n\n  if ('char-type' in conf && conf['char-type'] == 'uint8') this.types['char'] = this.types['uint8_t'];\n  if ('char-type' in conf && conf['char-type'] == 'int8') this.types['char'] = this.types['int8_t'];\n}\n/*\n * Sets the current endian value for the Parser. If the value is not valid,\n * throws an Error.\n *\n *\tendian\t\tEither 'big' or 'little' do determine the endianness we\n *\t\t\twant to read from or write to.\n *\n */\n\n\nCTypeParser.prototype.setEndian = function (endian) {\n  if (endian != 'big' && endian != 'little') throw new Error('invalid endian type, must be big or ' + 'little');\n  this.endian = endian;\n};\n/*\n * Returns the current value of the endian value for the parser.\n */\n\n\nCTypeParser.prototype.getEndian = function () {\n  return this.endian;\n};\n/*\n * A user has requested to add a type, let us honor their request. Yet, if their\n * request doth spurn us, send them unto the Hells which Dante describes.\n *\n * \tname\t\tThe string for the type definition we're adding\n *\n *\tvalue\t\tEither a string that is a type/array name or an object\n *\t\t\tthat describes a struct.\n */\n\n\nCTypeParser.prototype.typedef = function (name, value) {\n  var type;\n  if (name === undefined) throw new (Error('missing required typedef argument: name'))();\n  if (value === undefined) throw new (Error('missing required typedef argument: value'))();\n  if (typeof name != 'string') throw new (Error('the name of a type must be a string'))();\n  type = ctParseType(name);\n  if (type['len'] !== undefined) throw new Error('Cannot have an array in the typedef name');\n  if (name in this.types) throw new Error('typedef name already present: ' + name);\n  if (typeof value != 'string' && !(value instanceof Array)) throw new Error('typedef value must either be a string or ' + 'struct');\n\n  if (typeof value == 'string') {\n    type = ctParseType(value);\n\n    if (type['len'] !== undefined) {\n      if (isNaN(parseInt(type['len'], 10))) throw new (Error('typedef value must use ' + 'fixed size array when outside of a ' + 'struct'))();\n    }\n\n    this.types[name] = value;\n  } else {\n    /* We have a struct, validate it */\n    ctCheckReq(value, this.types);\n    this.types[name] = value;\n  }\n};\n/*\n * Include all of the typedefs, but none of the built in types. This should be\n * treated as read-only.\n */\n\n\nCTypeParser.prototype.lstypes = function () {\n  var key;\n  var ret = {};\n\n  for (key in this.types) {\n    if (key in deftypes) continue;\n    ret[key] = this.types[key];\n  }\n\n  return ret;\n};\n/*\n * Given a type string that may have array types that aren't numbers, try and\n * fill them in from the values object. The object should be of the format where\n * indexing into it should return a number for that type.\n *\n *\tstr\t\tThe type string\n *\n *\tvalues\t\tAn object that can be used to fulfill type information\n */\n\n\nfunction ctResolveArray(str, values) {\n  var ret = '';\n  var type = ctParseType(str);\n\n  while (type['len'] !== undefined) {\n    if (isNaN(parseInt(type['len'], 10))) {\n      if (typeof values[type['len']] != 'number') throw new Error('cannot sawp in non-number ' + 'for array value');\n      ret = '[' + values[type['len']] + ']' + ret;\n    } else {\n      ret = '[' + type['len'] + ']' + ret;\n    }\n\n    type = ctParseType(type['type']);\n  }\n\n  ret = type['type'] + ret;\n  return ret;\n}\n/*\n * [private] Either the typedef resolves to another type string or to a struct.\n * If it resolves to a struct, we just pass it off to read struct. If not, we\n * can just pass it off to read entry.\n */\n\n\nCTypeParser.prototype.resolveTypedef = function (type, dispatch, buffer, offset, value) {\n  var pt;\n  mod_assert.ok(type in this.types);\n\n  if (typeof this.types[type] == 'string') {\n    pt = ctParseType(this.types[type]);\n    if (dispatch == 'read') return this.readEntry(pt, buffer, offset);else if (dispatch == 'write') return this.writeEntry(value, pt, buffer, offset);else throw new Error('invalid dispatch type to ' + 'resolveTypedef');\n  } else {\n    if (dispatch == 'read') return this.readStruct(this.types[type], buffer, offset);else if (dispatch == 'write') return this.writeStruct(value, this.types[type], buffer, offset);else throw new Error('invalid dispatch type to ' + 'resolveTypedef');\n  }\n};\n/*\n * [private] Try and read in the specific entry.\n */\n\n\nCTypeParser.prototype.readEntry = function (type, buffer, offset) {\n  var parse, len;\n  /*\n   * Because we want to special case char[]s this is unfortunately\n   * a bit uglier than it really should be. We want to special\n   * case char[]s so that we return a node buffer, thus they are a\n   * first class type where as all other arrays just call into a\n   * generic array routine which calls their data-specific routine\n   * the specified number of times.\n   *\n   * The valid dispatch options we have are:\n   *  - Array and char => char[] handler\n   *  - Generic array handler\n   *  - Generic typedef handler\n   *  - Basic type handler\n   */\n\n  if (type['len'] !== undefined) {\n    len = parseInt(type['len'], 10);\n    if (isNaN(len)) throw new Error('somehow got a non-numeric length');\n    if (type['type'] == 'char') parse = this.types['char[]']['read'](len, this.endian, buffer, offset);else parse = this.readArray(type['type'], len, buffer, offset);\n  } else {\n    if (type['type'] in deftypes) parse = this.types[type['type']]['read'](this.endian, buffer, offset);else parse = this.resolveTypedef(type['type'], 'read', buffer, offset);\n  }\n\n  return parse;\n};\n/*\n * [private] Read an array of data\n */\n\n\nCTypeParser.prototype.readArray = function (type, length, buffer, offset) {\n  var ii, ent, pt;\n  var baseOffset = offset;\n  var ret = new Array(length);\n  pt = ctParseType(type);\n\n  for (ii = 0; ii < length; ii++) {\n    ent = this.readEntry(pt, buffer, offset);\n    offset += ent['size'];\n    ret[ii] = ent['value'];\n  }\n\n  return {\n    value: ret,\n    size: offset - baseOffset\n  };\n};\n/*\n * [private] Read a single struct in.\n */\n\n\nCTypeParser.prototype.readStruct = function (def, buffer, offset) {\n  var parse, ii, type, entry, key;\n  var baseOffset = offset;\n  var ret = {};\n  /* Walk it and handle doing what's necessary */\n\n  for (ii = 0; ii < def.length; ii++) {\n    key = Object.keys(def[ii])[0];\n    entry = def[ii][key];\n    /* Resolve all array values */\n\n    type = ctParseType(ctResolveArray(entry['type'], ret));\n    if ('offset' in entry) offset = baseOffset + entry['offset'];\n    parse = this.readEntry(type, buffer, offset);\n    offset += parse['size'];\n    ret[key] = parse['value'];\n  }\n\n  return {\n    value: ret,\n    size: offset - baseOffset\n  };\n};\n/*\n * This is what we were born to do. We read the data from a buffer and return it\n * in an object whose keys match the values from the object.\n *\n *\tdef\t\tThe array definition of the data to read in\n *\n *\tbuffer\t\tThe buffer to read data from\n *\n *\toffset\t\tThe offset to start writing to\n *\n * Returns an object where each key corresponds to an entry in def and the value\n * is the read value.\n */\n\n\nCTypeParser.prototype.readData = function (def, buffer, offset) {\n  /* Sanity check for arguments */\n  if (def === undefined) throw new Error('missing definition for what we should be' + 'parsing');\n  if (buffer === undefined) throw new Error('missing buffer for what we should be ' + 'parsing');\n  if (offset === undefined) throw new Error('missing offset for what we should be ' + 'parsing');\n  /* Sanity check the object definition */\n\n  ctCheckReq(def, this.types);\n  return this.readStruct(def, buffer, offset)['value'];\n};\n/*\n * [private] Write out an array of data\n */\n\n\nCTypeParser.prototype.writeArray = function (value, type, length, buffer, offset) {\n  var ii, pt;\n  var baseOffset = offset;\n  if (!(value instanceof Array)) throw new Error('asked to write an array, but value is not ' + 'an array');\n  if (value.length != length) throw new Error('asked to write array of length ' + length + ' but that does not match value length: ' + value.length);\n  pt = ctParseType(type);\n\n  for (ii = 0; ii < length; ii++) offset += this.writeEntry(value[ii], pt, buffer, offset);\n\n  return offset - baseOffset;\n};\n/*\n * [private] Write the specific entry\n */\n\n\nCTypeParser.prototype.writeEntry = function (value, type, buffer, offset) {\n  var len, ret;\n\n  if (type['len'] !== undefined) {\n    len = parseInt(type['len'], 10);\n    if (isNaN(len)) throw new Error('somehow got a non-numeric length');\n    if (type['type'] == 'char') ret = this.types['char[]']['write'](value, len, this.endian, buffer, offset);else ret = this.writeArray(value, type['type'], len, buffer, offset);\n  } else {\n    if (type['type'] in deftypes) ret = this.types[type['type']]['write'](value, this.endian, buffer, offset);else ret = this.resolveTypedef(type['type'], 'write', buffer, offset, value);\n  }\n\n  return ret;\n};\n/*\n * [private] Write a single struct out.\n */\n\n\nCTypeParser.prototype.writeStruct = function (value, def, buffer, offset) {\n  var ii, entry, type, key;\n  var baseOffset = offset;\n  var vals = {};\n\n  for (ii = 0; ii < def.length; ii++) {\n    key = Object.keys(def[ii])[0];\n    entry = def[ii][key];\n    type = ctParseType(ctResolveArray(entry['type'], vals));\n    if ('offset' in entry) offset = baseOffset + entry['offset'];\n    offset += this.writeEntry(value[ii], type, buffer, offset);\n    /* Now that we've written it out, we can use it for arrays */\n\n    vals[key] = value[ii];\n  }\n\n  return offset;\n};\n/*\n * Unfortunately, we're stuck with the sins of an initial poor design. Because\n * of that, we are going to have to support the old way of writing data via\n * writeData. There we insert the values that you want to write into the\n * definition. A little baroque. Internally, we use the new model. So we need to\n * just get those values out of there. But to maintain the principle of least\n * surprise, we're not going to modify the input data.\n */\n\n\nfunction getValues(def) {\n  var ii, out, key;\n  out = [];\n\n  for (ii = 0; ii < def.length; ii++) {\n    key = Object.keys(def[ii])[0];\n    mod_assert.ok('value' in def[ii][key]);\n    out.push(def[ii][key]['value']);\n  }\n\n  return out;\n}\n/*\n * This is the second half of what we were born to do, write out the data\n * itself. Historically this function required you to put your values in the\n * definition section. This was not the smartest thing to do and a bit of an\n * oversight to be honest. As such, this function now takes a values argument.\n * If values is non-null and non-undefined, it will be used to determine the\n * values. This means that the old method is still supported, but is no longer\n * acceptable.\n *\n *\tdef\t\tThe array definition of the data to write out with\n *\t\t\tvalues\n *\n *\tbuffer\t\tThe buffer to write to\n *\n *\toffset\t\tThe offset in the buffer to write to\n *\n *\tvalues\t\tAn array of values to write.\n */\n\n\nCTypeParser.prototype.writeData = function (def, buffer, offset, values) {\n  var hv;\n  if (def === undefined) throw new Error('missing definition for what we should be' + 'parsing');\n  if (buffer === undefined) throw new Error('missing buffer for what we should be ' + 'parsing');\n  if (offset === undefined) throw new Error('missing offset for what we should be ' + 'parsing');\n  hv = values != null && values != undefined;\n\n  if (hv) {\n    if (!Array.isArray(values)) throw new Error('missing values for writing');\n    ctCheckReq(def, this.types);\n  } else {\n    ctCheckReq(def, this.types, ['value']);\n  }\n\n  this.writeStruct(hv ? values : getValues(def), def, buffer, offset);\n};\n/*\n * Functions to go to and from 64 bit numbers in a way that is compatible with\n * Javascript limitations. There are two sets. One where the user is okay with\n * an approximation and one where they are definitely not okay with an\n * approximation.\n */\n\n/*\n * Attempts to convert an array of two integers returned from rsint64 / ruint64\n * into an absolute 64 bit number. If however the value would exceed 2^52 this\n * will instead throw an error. The mantissa in a double is a 52 bit number and\n * rather than potentially give you a value that is an approximation this will\n * error. If you would rather an approximation, please see toApprox64.\n *\n *\tval\t\tAn array of two 32-bit integers\n */\n\n\nfunction toAbs64(val) {\n  if (val === undefined) throw new Error('missing required arg: value');\n  if (!Array.isArray(val)) throw new Error('value must be an array');\n  if (val.length != 2) throw new Error('value must be an array of length 2');\n  /* We have 20 bits worth of precision in this range */\n\n  if (val[0] >= 0x100000) throw new Error('value would become approximated');\n  return val[0] * Math.pow(2, 32) + val[1];\n}\n/*\n * Will return the 64 bit value as returned in an array from rsint64 / ruint64\n * to a value as close as it can. Note that Javascript stores all numbers as a\n * double and the mantissa only has 52 bits. Thus this version may approximate\n * the value.\n *\n *\tval\t\tAn array of two 32-bit integers\n */\n\n\nfunction toApprox64(val) {\n  if (val === undefined) throw new Error('missing required arg: value');\n  if (!Array.isArray(val)) throw new Error('value must be an array');\n  if (val.length != 2) throw new Error('value must be an array of length 2');\n  return Math.pow(2, 32) * val[0] + val[1];\n}\n\nfunction parseCTF(json, conf) {\n  var ctype = new CTypeParser(conf);\n  mod_ctf.ctfParseJson(json, ctype);\n  return ctype;\n}\n/*\n * Export the few things we actually want to. Currently this is just the CType\n * Parser and ctio.\n */\n\n\nexports.Parser = CTypeParser;\nexports.toAbs64 = toAbs64;\nexports.toApprox64 = toApprox64;\nexports.parseCTF = parseCTF;\nexports.ruint8 = mod_ctio.ruint8;\nexports.ruint16 = mod_ctio.ruint16;\nexports.ruint32 = mod_ctio.ruint32;\nexports.ruint64 = mod_ctio.ruint64;\nexports.wuint8 = mod_ctio.wuint8;\nexports.wuint16 = mod_ctio.wuint16;\nexports.wuint32 = mod_ctio.wuint32;\nexports.wuint64 = mod_ctio.wuint64;\nexports.rsint8 = mod_ctio.rsint8;\nexports.rsint16 = mod_ctio.rsint16;\nexports.rsint32 = mod_ctio.rsint32;\nexports.rsint64 = mod_ctio.rsint64;\nexports.wsint8 = mod_ctio.wsint8;\nexports.wsint16 = mod_ctio.wsint16;\nexports.wsint32 = mod_ctio.wsint32;\nexports.wsint64 = mod_ctio.wsint64;\nexports.rfloat = mod_ctio.rfloat;\nexports.rdouble = mod_ctio.rdouble;\nexports.wfloat = mod_ctio.wfloat;\nexports.wdouble = mod_ctio.wdouble;","map":null,"metadata":{},"sourceType":"script"}