{"ast":null,"code":"import React, { Component } from 'react';\nimport PropTypes from 'prop-types';\nimport { withStyles } from '@material-ui/core';\nimport Paper from '@material-ui/core/Paper';\nvar commonjsGlobal = typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};\n\nfunction unwrapExports(x) {\n  return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x.default : x;\n}\n\nfunction createCommonjsModule(fn, module) {\n  return module = {\n    exports: {}\n  }, fn(module, module.exports), module.exports;\n}\n\nvar reactSwipe = createCommonjsModule(function (module, exports) {\n  (function (global, factory) {\n    {\n      factory(exports, React, PropTypes);\n    }\n  })(commonjsGlobal, function (exports, _react, _propTypes) {\n    Object.defineProperty(exports, \"__esModule\", {\n      value: true\n    });\n    exports.setHasSupportToCaptureOption = setHasSupportToCaptureOption;\n\n    var _react2 = _interopRequireDefault(_react);\n\n    var _propTypes2 = _interopRequireDefault(_propTypes);\n\n    function _interopRequireDefault(obj) {\n      return obj && obj.__esModule ? obj : {\n        default: obj\n      };\n    }\n\n    var _extends = Object.assign || function (target) {\n      for (var i = 1; i < arguments.length; i++) {\n        var source = arguments[i];\n\n        for (var key in source) {\n          if (Object.prototype.hasOwnProperty.call(source, key)) {\n            target[key] = source[key];\n          }\n        }\n      }\n\n      return target;\n    };\n\n    function _objectWithoutProperties(obj, keys) {\n      var target = {};\n\n      for (var i in obj) {\n        if (keys.indexOf(i) >= 0) continue;\n        if (!Object.prototype.hasOwnProperty.call(obj, i)) continue;\n        target[i] = obj[i];\n      }\n\n      return target;\n    }\n\n    function _classCallCheck(instance, Constructor) {\n      if (!(instance instanceof Constructor)) {\n        throw new TypeError(\"Cannot call a class as a function\");\n      }\n    }\n\n    var _createClass = function () {\n      function defineProperties(target, props) {\n        for (var i = 0; i < props.length; i++) {\n          var descriptor = props[i];\n          descriptor.enumerable = descriptor.enumerable || false;\n          descriptor.configurable = true;\n          if (\"value\" in descriptor) descriptor.writable = true;\n          Object.defineProperty(target, descriptor.key, descriptor);\n        }\n      }\n\n      return function (Constructor, protoProps, staticProps) {\n        if (protoProps) defineProperties(Constructor.prototype, protoProps);\n        if (staticProps) defineProperties(Constructor, staticProps);\n        return Constructor;\n      };\n    }();\n\n    function _possibleConstructorReturn(self, call) {\n      if (!self) {\n        throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n      }\n\n      return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self;\n    }\n\n    function _inherits(subClass, superClass) {\n      if (typeof superClass !== \"function\" && superClass !== null) {\n        throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n      }\n\n      subClass.prototype = Object.create(superClass && superClass.prototype, {\n        constructor: {\n          value: subClass,\n          enumerable: false,\n          writable: true,\n          configurable: true\n        }\n      });\n      if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n    }\n\n    var supportsCaptureOption = false;\n\n    function setHasSupportToCaptureOption(hasSupport) {\n      supportsCaptureOption = hasSupport;\n    }\n\n    try {\n      addEventListener(\"test\", null, Object.defineProperty({}, 'capture', {\n        get: function get() {\n          setHasSupportToCaptureOption(true);\n        }\n      }));\n    } catch (e) {}\n\n    function getSafeEventHandlerOpts() {\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {\n        capture: true\n      };\n      return supportsCaptureOption ? options : options.capture;\n    }\n    /**\n     * [getPosition returns a position element that works for mouse or touch events]\n     * @param  {[Event]} event [the received event]\n     * @return {[Object]}      [x and y coords]\n     */\n\n\n    function getPosition(event) {\n      if ('touches' in event) {\n        var _event$touches$ = event.touches[0],\n            pageX = _event$touches$.pageX,\n            pageY = _event$touches$.pageY;\n        return {\n          x: pageX,\n          y: pageY\n        };\n      }\n\n      var screenX = event.screenX,\n          screenY = event.screenY;\n      return {\n        x: screenX,\n        y: screenY\n      };\n    }\n\n    var ReactSwipe = function (_Component) {\n      _inherits(ReactSwipe, _Component);\n\n      function ReactSwipe() {\n        var _ref;\n\n        _classCallCheck(this, ReactSwipe);\n\n        for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n          args[_key] = arguments[_key];\n        }\n\n        var _this = _possibleConstructorReturn(this, (_ref = ReactSwipe.__proto__ || Object.getPrototypeOf(ReactSwipe)).call.apply(_ref, [this].concat(args)));\n\n        _this._handleSwipeStart = _this._handleSwipeStart.bind(_this);\n        _this._handleSwipeMove = _this._handleSwipeMove.bind(_this);\n        _this._handleSwipeEnd = _this._handleSwipeEnd.bind(_this);\n        _this._onMouseDown = _this._onMouseDown.bind(_this);\n        _this._onMouseMove = _this._onMouseMove.bind(_this);\n        _this._onMouseUp = _this._onMouseUp.bind(_this);\n        return _this;\n      }\n\n      _createClass(ReactSwipe, [{\n        key: 'componentDidMount',\n        value: function componentDidMount() {\n          if (this.swiper) {\n            this.swiper.addEventListener('touchmove', this._handleSwipeMove, getSafeEventHandlerOpts({\n              capture: true,\n              passive: false\n            }));\n          }\n        }\n      }, {\n        key: 'componentWillUnmount',\n        value: function componentWillUnmount() {\n          if (this.swiper) {\n            this.swiper.removeEventListener('touchmove', this._handleSwipeMove, getSafeEventHandlerOpts({\n              capture: true,\n              passive: false\n            }));\n          }\n        }\n      }, {\n        key: '_onMouseDown',\n        value: function _onMouseDown(event) {\n          if (!this.props.allowMouseEvents) {\n            return;\n          }\n\n          this.mouseDown = true;\n          document.addEventListener('mouseup', this._onMouseUp);\n          document.addEventListener('mousemove', this._onMouseMove);\n\n          this._handleSwipeStart(event);\n        }\n      }, {\n        key: '_onMouseMove',\n        value: function _onMouseMove(event) {\n          if (!this.mouseDown) {\n            return;\n          }\n\n          this._handleSwipeMove(event);\n        }\n      }, {\n        key: '_onMouseUp',\n        value: function _onMouseUp(event) {\n          this.mouseDown = false;\n          document.removeEventListener('mouseup', this._onMouseUp);\n          document.removeEventListener('mousemove', this._onMouseMove);\n\n          this._handleSwipeEnd(event);\n        }\n      }, {\n        key: '_handleSwipeStart',\n        value: function _handleSwipeStart(event) {\n          var _getPosition = getPosition(event),\n              x = _getPosition.x,\n              y = _getPosition.y;\n\n          this.moveStart = {\n            x: x,\n            y: y\n          };\n          this.props.onSwipeStart(event);\n        }\n      }, {\n        key: '_handleSwipeMove',\n        value: function _handleSwipeMove(event) {\n          if (!this.moveStart) {\n            return;\n          }\n\n          var _getPosition2 = getPosition(event),\n              x = _getPosition2.x,\n              y = _getPosition2.y;\n\n          var deltaX = x - this.moveStart.x;\n          var deltaY = y - this.moveStart.y;\n          this.moving = true; // handling the responsability of cancelling the scroll to\n          // the component handling the event\n\n          var shouldPreventDefault = this.props.onSwipeMove({\n            x: deltaX,\n            y: deltaY\n          }, event);\n\n          if (shouldPreventDefault) {\n            event.preventDefault();\n          }\n\n          this.movePosition = {\n            deltaX: deltaX,\n            deltaY: deltaY\n          };\n        }\n      }, {\n        key: '_handleSwipeEnd',\n        value: function _handleSwipeEnd(event) {\n          this.props.onSwipeEnd(event);\n          var tolerance = this.props.tolerance;\n\n          if (this.moving && this.movePosition) {\n            if (this.movePosition.deltaX < -tolerance) {\n              this.props.onSwipeLeft(1, event);\n            } else if (this.movePosition.deltaX > tolerance) {\n              this.props.onSwipeRight(1, event);\n            }\n\n            if (this.movePosition.deltaY < -tolerance) {\n              this.props.onSwipeUp(1, event);\n            } else if (this.movePosition.deltaY > tolerance) {\n              this.props.onSwipeDown(1, event);\n            }\n          }\n\n          this.moveStart = null;\n          this.moving = false;\n          this.movePosition = null;\n        }\n      }, {\n        key: 'render',\n        value: function render() {\n          var _this2 = this;\n\n          var _props = this.props,\n              tagName = _props.tagName,\n              className = _props.className,\n              style = _props.style,\n              children = _props.children,\n              allowMouseEvents = _props.allowMouseEvents,\n              onSwipeUp = _props.onSwipeUp,\n              onSwipeDown = _props.onSwipeDown,\n              onSwipeLeft = _props.onSwipeLeft,\n              onSwipeRight = _props.onSwipeRight,\n              onSwipeStart = _props.onSwipeStart,\n              onSwipeMove = _props.onSwipeMove,\n              onSwipeEnd = _props.onSwipeEnd,\n              props = _objectWithoutProperties(_props, ['tagName', 'className', 'style', 'children', 'allowMouseEvents', 'onSwipeUp', 'onSwipeDown', 'onSwipeLeft', 'onSwipeRight', 'onSwipeStart', 'onSwipeMove', 'onSwipeEnd']);\n\n          return _react2.default.createElement(this.props.tagName, _extends({\n            ref: function ref(node) {\n              return _this2.swiper = node;\n            },\n            onMouseDown: this._onMouseDown,\n            onTouchStart: this._handleSwipeStart,\n            onTouchEnd: this._handleSwipeEnd,\n            className: className,\n            style: style\n          }, props), children);\n        }\n      }]);\n\n      return ReactSwipe;\n    }(_react.Component);\n\n    ReactSwipe.displayName = 'ReactSwipe';\n    ReactSwipe.propTypes = {\n      tagName: _propTypes2.default.string,\n      className: _propTypes2.default.string,\n      style: _propTypes2.default.object,\n      children: _propTypes2.default.node,\n      allowMouseEvents: _propTypes2.default.bool,\n      onSwipeUp: _propTypes2.default.func,\n      onSwipeDown: _propTypes2.default.func,\n      onSwipeLeft: _propTypes2.default.func,\n      onSwipeRight: _propTypes2.default.func,\n      onSwipeStart: _propTypes2.default.func,\n      onSwipeMove: _propTypes2.default.func,\n      onSwipeEnd: _propTypes2.default.func,\n      tolerance: _propTypes2.default.number.isRequired\n    };\n    ReactSwipe.defaultProps = {\n      tagName: 'div',\n      allowMouseEvents: false,\n      onSwipeUp: function onSwipeUp() {},\n      onSwipeDown: function onSwipeDown() {},\n      onSwipeLeft: function onSwipeLeft() {},\n      onSwipeRight: function onSwipeRight() {},\n      onSwipeStart: function onSwipeStart() {},\n      onSwipeMove: function onSwipeMove() {},\n      onSwipeEnd: function onSwipeEnd() {},\n      tolerance: 0\n    };\n    exports.default = ReactSwipe;\n  });\n});\nunwrapExports(reactSwipe);\nvar lib = createCommonjsModule(function (module, exports) {\n  (function (global, factory) {\n    {\n      factory(exports, reactSwipe);\n    }\n  })(commonjsGlobal, function (exports, _reactSwipe) {\n    Object.defineProperty(exports, \"__esModule\", {\n      value: true\n    });\n\n    var _reactSwipe2 = _interopRequireDefault(_reactSwipe);\n\n    function _interopRequireDefault(obj) {\n      return obj && obj.__esModule ? obj : {\n        default: obj\n      };\n    }\n\n    exports.default = _reactSwipe2.default;\n  });\n});\nvar Swipe = unwrapExports(lib);\n\nvar classCallCheck = function (instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n};\n\nvar createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n}();\n\nvar _extends = Object.assign || function (target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i];\n\n    for (var key in source) {\n      if (Object.prototype.hasOwnProperty.call(source, key)) {\n        target[key] = source[key];\n      }\n    }\n  }\n\n  return target;\n};\n\nvar inherits = function (subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n};\n\nvar objectWithoutProperties = function (obj, keys) {\n  var target = {};\n\n  for (var i in obj) {\n    if (keys.indexOf(i) >= 0) continue;\n    if (!Object.prototype.hasOwnProperty.call(obj, i)) continue;\n    target[i] = obj[i];\n  }\n\n  return target;\n};\n\nvar possibleConstructorReturn = function (self, call) {\n  if (!self) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self;\n};\n\nvar toConsumableArray = function (arr) {\n  if (Array.isArray(arr)) {\n    for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];\n\n    return arr2;\n  } else {\n    return Array.from(arr);\n  }\n};\n\nvar CarouselSlide = function CarouselSlide(props) {\n  var classes = props.classes,\n      children = props.children,\n      focused = props.focused,\n      rest = objectWithoutProperties(props, ['classes', 'children', 'focused']);\n  var className = classes.root;\n  if (focused) className += ' ' + classes.focused;\n  return React.createElement('div', _extends({\n    className: className\n  }, rest), React.cloneElement(children, {\n    focused: focused\n  }));\n};\n\nCarouselSlide.propTypes = {\n  classes: PropTypes.shape({}).isRequired,\n  children: PropTypes.node.isRequired,\n  focused: PropTypes.bool\n};\nCarouselSlide.defaultProps = {\n  focused: false\n};\nvar size = 70;\nvar stickness = 70;\nvar margin = (-3 * size + 2 * stickness + 100) / 4;\n\nvar styles = function styles() {\n  return {\n    root: {\n      display: 'inline-block',\n      position: 'relative',\n      verticalAlign: 'middle',\n      width: size + '%',\n      margin: '0 ' + margin + '%',\n      opacity: 0.5,\n      transition: 'padding,box-shadow 150ms cubic-bezier(0.4, 0, 0.2, 1)',\n      zIndex: 9,\n      padding: '5%',\n      boxSizing: 'border-box',\n      cursor: 'pointer',\n      '-webkit-tap-highlight-color': 'rgba(255, 255, 255, 0)'\n    },\n    focused: {\n      margin: '0 -' + stickness + '%',\n      padding: 0,\n      opacity: 1,\n      zIndex: 10,\n      cursor: 'initial',\n      transitionDuration: '400ms'\n    }\n  };\n};\n\nvar CarouselSlide$1 = withStyles(styles)(CarouselSlide);\nvar styles$1 = {\n  dots: {\n    position: 'relative',\n    height: 16\n  },\n  dotOuter: {\n    width: 8,\n    height: 8,\n    padding: 4,\n    float: 'left',\n    position: 'absolute'\n  },\n  dot: {\n    width: 8,\n    height: 8,\n    background: '#777',\n    transition: 'all 400ms cubic-bezier(0.4, 0.0, 0.2, 1)',\n    borderRadius: 4\n  }\n};\n\nvar Dots = function (_Component) {\n  inherits(Dots, _Component);\n\n  function Dots(props) {\n    classCallCheck(this, Dots);\n\n    var _this = possibleConstructorReturn(this, (Dots.__proto__ || Object.getPrototypeOf(Dots)).call(this, props));\n\n    _this.handleDotClick = function (index, event) {\n      if (_this.props.onDotClick != null) {\n        _this.props.onDotClick(index, event);\n      }\n    };\n\n    _this.state = {\n      previousIndex: props.index || 0\n    };\n    return _this;\n  }\n\n  createClass(Dots, [{\n    key: 'componentWillReceiveProps',\n    value: function componentWillReceiveProps(_ref) {\n      var _this2 = this;\n\n      var index = _ref.index;\n\n      if (index !== this.props.index) {\n        this.setState({\n          previousIndex: this.props.index\n        });\n        this.timeout = setTimeout(function () {\n          _this2.timeout = null;\n\n          _this2.setState({\n            previousIndex: index\n          });\n        }, 450);\n      }\n    }\n  }, {\n    key: 'componentWillUnmount',\n    value: function componentWillUnmount() {\n      if (this.timeout != null) {\n        clearTimeout(this.timeout);\n      }\n    }\n  }, {\n    key: 'render',\n    value: function render() {\n      var _this3 = this;\n\n      var _props = this.props,\n          classes = _props.classes,\n          count = _props.count,\n          index = _props.index,\n          _props$style = _props.style,\n          style = _props$style === undefined ? {} : _props$style,\n          onDotClick = _props.onDotClick,\n          other = objectWithoutProperties(_props, ['classes', 'count', 'index', 'style', 'onDotClick']);\n      var previousIndex = this.state.previousIndex;\n      return React.createElement('div', _extends({\n        style: _extends({}, style, {\n          margin: 'auto',\n          width: count * 16\n        })\n      }, other), React.createElement('div', {\n        className: classes.dots\n      }, [].concat(toConsumableArray(Array(count).keys())).map(function (i) {\n        return React.createElement('div', {\n          key: i,\n          className: classes.dotOuter,\n          style: {\n            left: i * 16,\n            cursor: onDotClick != null ? 'pointer' : 'inherit'\n          },\n          onClick: function onClick(event) {\n            return _this3.handleDotClick(i, event);\n          }\n        }, React.createElement(Paper, {\n          elevation: 0,\n          className: classes.dot,\n          style: {\n            opacity: i >= Math.min(previousIndex, index) && i <= Math.max(previousIndex, index) ? 0 : 0.5\n          }\n        }));\n      }), React.createElement(Paper, {\n        elevation: 0,\n        className: classes.dot,\n        style: {\n          position: 'absolute',\n          marginTop: 4,\n          left: Math.min(previousIndex, index) * 16 + 4,\n          width: Math.abs(previousIndex - index) * 16 + 8\n        }\n      })));\n    }\n  }]);\n  return Dots;\n}(Component);\n\nDots.propTypes = {\n  count: PropTypes.number.isRequired,\n  index: PropTypes.number.isRequired,\n  style: PropTypes.object,\n  onDotClick: PropTypes.func\n};\nvar Dots$1 = withStyles(styles$1)(Dots);\n\nvar Carousel = function (_Component) {\n  inherits(Carousel, _Component);\n\n  function Carousel() {\n    var _ref;\n\n    var _temp, _this, _ret;\n\n    classCallCheck(this, Carousel);\n\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = Carousel.__proto__ || Object.getPrototypeOf(Carousel)).call.apply(_ref, [this].concat(args))), _this), _this.state = {\n      focused: 0,\n      swipe: 0\n    }, _this.onSwipeMove = function (position) {\n      _this.setState({\n        swipe: position.x\n      });\n    }, _this.onSwipeEnd = function () {\n      var children = _this.props.children;\n      var _this$state = _this.state,\n          focused = _this$state.focused,\n          swipe = _this$state.swipe;\n\n      _this.setState({\n        swipe: 0\n      });\n\n      if (Math.abs(swipe) > 5) {\n        var direction = swipe > 0 ? -1 : 1;\n        var max = React.Children.count(children) - 1;\n\n        if (direction === -1 && focused !== 0 || direction === 1 && focused !== max) {\n          _this.setState({\n            focused: focused + direction\n          });\n        }\n      }\n    }, _this.handleFocus = function (index) {\n      _this.setState({\n        focused: index\n      });\n    }, _this.renderSlide = function (slide, i) {\n      var focused = _this.state.focused;\n      return React.cloneElement(slide, {\n        focused: i === focused,\n        onClick: function onClick() {\n          return _this.handleFocus(i);\n        }\n      });\n    }, _temp), possibleConstructorReturn(_this, _ret);\n  }\n\n  createClass(Carousel, [{\n    key: 'render',\n    value: function render() {\n      var _props = this.props,\n          classes = _props.classes,\n          children = _props.children;\n      var focused = this.state.focused;\n      return React.createElement('div', {\n        className: classes.root\n      }, React.createElement('div', {\n        className: classes.carousel\n      }, React.createElement(Swipe, {\n        onSwipeStart: this.onSwipeStart,\n        onSwipeMove: this.onSwipeMove,\n        onSwipeEnd: this.onSwipeEnd\n      }, React.createElement('div', {\n        className: classes.scroller,\n        style: {\n          left: (focused - 1) * -(size + 2 * margin) + '%'\n        }\n      }, React.Children.map(children, this.renderSlide)))), React.createElement('div', {\n        className: classes.dots\n      }, React.createElement(Dots$1, {\n        index: focused,\n        count: React.Children.count(children),\n        onDotClick: this.handleFocus\n      })));\n    }\n  }]);\n  return Carousel;\n}(Component);\n\nCarousel.propTypes = {\n  classes: PropTypes.shape({}).isRequired,\n  children: PropTypes.node.isRequired\n};\n\nvar transition = function transition() {\n  var duration = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 150;\n  return 'all ' + duration + 'ms cubic-bezier(0.4, 0, 0.2, 1)';\n};\n\nvar styles$2 = function styles(theme) {\n  return {\n    root: {},\n    carousel: {\n      padding: '10px 0 30px',\n      whiteSpace: 'nowrap',\n      overflowX: 'hidden'\n    },\n    scroller: {\n      position: 'relative',\n      transition: transition()\n    },\n    dots: {\n      marginTop: 8,\n      marginBottom: 8\n    }\n  };\n};\n\nvar Carousel$1 = withStyles(styles$2)(Carousel);\nexport { Carousel$1 as Carousel, CarouselSlide$1 as CarouselSlide };","map":null,"metadata":{},"sourceType":"module"}