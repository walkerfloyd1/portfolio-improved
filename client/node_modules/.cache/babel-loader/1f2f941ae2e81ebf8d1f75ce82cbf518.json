{"ast":null,"code":"var through = require('through2');\n\nvar speedometer = require('speedometer');\n\nmodule.exports = function (options, onprogress) {\n  if (typeof options === 'function') return module.exports(null, options);\n  options = options || {};\n  var length = options.length || 0;\n  var time = options.time || 0;\n  var drain = options.drain || false;\n  var transferred = options.transferred || 0;\n  var nextUpdate = Date.now() + time;\n  var delta = 0;\n  var speed = speedometer(options.speed || 5000);\n  var startTime = Date.now();\n  var update = {\n    percentage: 0,\n    transferred: transferred,\n    length: length,\n    remaining: length,\n    eta: 0,\n    runtime: 0\n  };\n\n  var emit = function (ended) {\n    update.delta = delta;\n    update.percentage = ended ? 100 : length ? transferred / length * 100 : 0;\n    update.speed = speed(delta);\n    update.eta = Math.round(update.remaining / update.speed);\n    update.runtime = parseInt((Date.now() - startTime) / 1000);\n    nextUpdate = Date.now() + time;\n    delta = 0;\n    tr.emit('progress', update);\n  };\n\n  var write = function (chunk, enc, callback) {\n    var len = options.objectMode ? 1 : chunk.length;\n    transferred += len;\n    delta += len;\n    update.transferred = transferred;\n    update.remaining = length >= transferred ? length - transferred : 0;\n    if (Date.now() >= nextUpdate) emit(false);\n    callback(null, chunk);\n  };\n\n  var end = function (callback) {\n    emit(true);\n    callback();\n  };\n\n  var tr = through(options.objectMode ? {\n    objectMode: true,\n    highWaterMark: 16\n  } : {}, write, end);\n\n  var onlength = function (newLength) {\n    length = newLength;\n    update.length = length;\n    update.remaining = length - update.transferred;\n    tr.emit('length', length);\n  }; // Expose `onlength()` handler as `setLength()` to support custom use cases where length\n  // is not known until after a few chunks have already been pumped, or is\n  // calculated on the fly.\n\n\n  tr.setLength = onlength;\n  tr.on('pipe', function (stream) {\n    if (typeof length === 'number') return; // Support http module\n\n    if (stream.readable && !stream.writable && stream.headers) {\n      return onlength(parseInt(stream.headers['content-length'] || 0));\n    } // Support streams with a length property\n\n\n    if (typeof stream.length === 'number') {\n      return onlength(stream.length);\n    } // Support request module\n\n\n    stream.on('response', function (res) {\n      if (!res || !res.headers) return;\n      if (res.headers['content-encoding'] === 'gzip') return;\n\n      if (res.headers['content-length']) {\n        return onlength(parseInt(res.headers['content-length']));\n      }\n    });\n  });\n  if (drain) tr.resume();\n  if (onprogress) tr.on('progress', onprogress);\n\n  tr.progress = function () {\n    update.speed = speed(0);\n    update.eta = Math.round(update.remaining / update.speed);\n    return update;\n  };\n\n  return tr;\n};","map":null,"metadata":{},"sourceType":"script"}