{"ast":null,"code":"// Load modules\n// Declare internals\nvar internals = {};\ninternals.hexTable = new Array(256);\n\nfor (var h = 0; h < 256; ++h) {\n  internals.hexTable[h] = '%' + ((h < 16 ? '0' : '') + h.toString(16)).toUpperCase();\n}\n\nexports.arrayToObject = function (source, options) {\n  var obj = options.plainObjects ? Object.create(null) : {};\n\n  for (var i = 0, il = source.length; i < il; ++i) {\n    if (typeof source[i] !== 'undefined') {\n      obj[i] = source[i];\n    }\n  }\n\n  return obj;\n};\n\nexports.merge = function (target, source, options) {\n  if (!source) {\n    return target;\n  }\n\n  if (typeof source !== 'object') {\n    if (Array.isArray(target)) {\n      target.push(source);\n    } else if (typeof target === 'object') {\n      target[source] = true;\n    } else {\n      target = [target, source];\n    }\n\n    return target;\n  }\n\n  if (typeof target !== 'object') {\n    target = [target].concat(source);\n    return target;\n  }\n\n  if (Array.isArray(target) && !Array.isArray(source)) {\n    target = exports.arrayToObject(target, options);\n  }\n\n  var keys = Object.keys(source);\n\n  for (var k = 0, kl = keys.length; k < kl; ++k) {\n    var key = keys[k];\n    var value = source[key];\n\n    if (!Object.prototype.hasOwnProperty.call(target, key)) {\n      target[key] = value;\n    } else {\n      target[key] = exports.merge(target[key], value, options);\n    }\n  }\n\n  return target;\n};\n\nexports.decode = function (str) {\n  try {\n    return decodeURIComponent(str.replace(/\\+/g, ' '));\n  } catch (e) {\n    return str;\n  }\n};\n\nexports.encode = function (str) {\n  // This code was originally written by Brian White (mscdex) for the io.js core querystring library.\n  // It has been adapted here for stricter adherence to RFC 3986\n  if (str.length === 0) {\n    return str;\n  }\n\n  if (typeof str !== 'string') {\n    str = '' + str;\n  }\n\n  var out = '';\n\n  for (var i = 0, il = str.length; i < il; ++i) {\n    var c = str.charCodeAt(i);\n\n    if (c === 0x2D || // -\n    c === 0x2E || // .\n    c === 0x5F || // _\n    c === 0x7E || // ~\n    c >= 0x30 && c <= 0x39 || // 0-9\n    c >= 0x41 && c <= 0x5A || // a-z\n    c >= 0x61 && c <= 0x7A) {\n      // A-Z\n      out += str[i];\n      continue;\n    }\n\n    if (c < 0x80) {\n      out += internals.hexTable[c];\n      continue;\n    }\n\n    if (c < 0x800) {\n      out += internals.hexTable[0xC0 | c >> 6] + internals.hexTable[0x80 | c & 0x3F];\n      continue;\n    }\n\n    if (c < 0xD800 || c >= 0xE000) {\n      out += internals.hexTable[0xE0 | c >> 12] + internals.hexTable[0x80 | c >> 6 & 0x3F] + internals.hexTable[0x80 | c & 0x3F];\n      continue;\n    }\n\n    ++i;\n    c = 0x10000 + ((c & 0x3FF) << 10 | str.charCodeAt(i) & 0x3FF);\n    out += internals.hexTable[0xF0 | c >> 18] + internals.hexTable[0x80 | c >> 12 & 0x3F] + internals.hexTable[0x80 | c >> 6 & 0x3F] + internals.hexTable[0x80 | c & 0x3F];\n  }\n\n  return out;\n};\n\nexports.compact = function (obj, refs) {\n  if (typeof obj !== 'object' || obj === null) {\n    return obj;\n  }\n\n  refs = refs || [];\n  var lookup = refs.indexOf(obj);\n\n  if (lookup !== -1) {\n    return refs[lookup];\n  }\n\n  refs.push(obj);\n\n  if (Array.isArray(obj)) {\n    var compacted = [];\n\n    for (var i = 0, il = obj.length; i < il; ++i) {\n      if (typeof obj[i] !== 'undefined') {\n        compacted.push(obj[i]);\n      }\n    }\n\n    return compacted;\n  }\n\n  var keys = Object.keys(obj);\n\n  for (i = 0, il = keys.length; i < il; ++i) {\n    var key = keys[i];\n    obj[key] = exports.compact(obj[key], refs);\n  }\n\n  return obj;\n};\n\nexports.isRegExp = function (obj) {\n  return Object.prototype.toString.call(obj) === '[object RegExp]';\n};\n\nexports.isBuffer = function (obj) {\n  if (obj === null || typeof obj === 'undefined') {\n    return false;\n  }\n\n  return !!(obj.constructor && obj.constructor.isBuffer && obj.constructor.isBuffer(obj));\n};","map":null,"metadata":{},"sourceType":"script"}