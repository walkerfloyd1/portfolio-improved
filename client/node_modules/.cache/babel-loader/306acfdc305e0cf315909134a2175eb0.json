{"ast":null,"code":"'use strict';\n\nvar _extends = Object.assign || function (target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i];\n\n    for (var key in source) {\n      if (Object.prototype.hasOwnProperty.call(source, key)) {\n        target[key] = source[key];\n      }\n    }\n  }\n\n  return target;\n};\n\nvar _createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n}();\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nvar Promise = require('q');\n\nvar DEFAULT_OPTIONS = {\n  page: 1,\n  per_page: 100,\n  headers: {}\n};\n/**\n * Page that can be updated to iterate over pagination.\n * @type {Class}\n */\n\nvar Page = function () {\n  function Page(client, uri, params) {\n    var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : DEFAULT_OPTIONS;\n\n    _classCallCheck(this, Page);\n\n    this.list = [];\n    this.links = {};\n    this.client = client;\n    this.url = uri;\n    this.params = params || {};\n    this.options = options;\n  }\n  /**\n   * Fetch current page.\n   * @return {Promise<Page>}\n   */\n\n\n  _createClass(Page, [{\n    key: 'fetch',\n    value: function fetch(uri) {\n      var _this = this;\n\n      var _options = this.options,\n          page = _options.page,\n          per_page = _options.per_page,\n          headers = _options.headers;\n      return this.client.get(this.url, _extends({}, this.params, {\n        page: page,\n        per_page: per_page\n      }), {\n        headers: headers\n      }).then(function (response) {\n        _this.list = response.body;\n        _this.links = parseLinkHeader(response.headers.link); // Return itself\n\n        return _this;\n      });\n    }\n    /**\n     * Update the page by fetching a specific url.\n     * @param {String} uri\n     * @return {Promise<Page>}\n     */\n\n  }, {\n    key: 'update',\n    value: function update(uri) {\n      this.url = uri;\n      return this.fetch();\n    } // Has next or previous page\n\n  }, {\n    key: 'hasNext',\n    value: function hasNext() {\n      return !!this.links.next;\n    }\n  }, {\n    key: 'hasPrev',\n    value: function hasPrev() {\n      return !!this.links.prev;\n    }\n    /**\n     * Fetch next page.\n     * @return {Promise<Page>}\n     */\n\n  }, {\n    key: 'next',\n    value: function next() {\n      if (!this.hasNext()) {\n        return Promise.reject(new Error('Paginated results doesn\\'t have nore page'));\n      }\n\n      return this.update(this.links.next);\n    }\n    /**\n     * Fetch previous page.\n     * @return {Promise<Page>}\n     */\n\n  }, {\n    key: 'prev',\n    value: function prev() {\n      if (!this.hasPrev()) {\n        return Promise.reject(new Error('Paginated results doesn\\'t have a precedent page'));\n      }\n\n      return this.update(this.links.prev);\n    }\n    /**\n     * Fetch all items by iterating over pages.\n     * @return {Promise<Array>}\n     */\n\n  }, {\n    key: 'all',\n    value: function all() {\n      var results = [];\n\n      function handlePage(page) {\n        results = results.concat(page.list);\n\n        if (!page.hasNext()) {\n          return results;\n        }\n\n        return page.next().then(handlePage);\n      }\n\n      return Promise(handlePage(this));\n    }\n  }]);\n\n  return Page;\n}();\n/**\n * Extract next and prev from link header\n * @param  {String} header\n * @return {Object}\n */\n\n\nfunction parseLinkHeader(header) {\n  if (!header) {\n    return {};\n  } // Split parts by comma\n\n\n  var parts = header.split(',');\n  var links = {}; // Parse each part into a named link\n\n  parts.forEach(function (p) {\n    var section = p.split(';');\n\n    if (section.length != 2) {\n      throw new Error('section could not be split on \";\"');\n    }\n\n    var url = section[0].replace(/<(.*)>/, '$1').trim();\n    var name = section[1].replace(/rel=\"(.*)\"/, '$1').trim();\n    links[name] = url;\n  });\n  return links;\n}\n\nmodule.exports = Page;","map":null,"metadata":{},"sourceType":"script"}