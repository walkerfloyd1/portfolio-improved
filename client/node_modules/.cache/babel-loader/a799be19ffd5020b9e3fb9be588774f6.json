{"ast":null,"code":"// Copyright 2012 Joyent, Inc.  All rights reserved.\nvar assert = require('assert-plus');\n\nvar crypto = require('crypto');\n\nvar http = require('http');\n\nvar sprintf = require('util').format; ///--- Globals\n\n\nvar Algorithms = {\n  'rsa-sha1': true,\n  'rsa-sha256': true,\n  'rsa-sha512': true,\n  'dsa-sha1': true,\n  'hmac-sha1': true,\n  'hmac-sha256': true,\n  'hmac-sha512': true\n};\nvar Authorization = 'Signature keyId=\"%s\",algorithm=\"%s\",headers=\"%s\",signature=\"%s\"'; ///--- Specific Errors\n\nfunction MissingHeaderError(message) {\n  this.name = 'MissingHeaderError';\n  this.message = message;\n  this.stack = new Error().stack;\n}\n\nMissingHeaderError.prototype = new Error();\n\nfunction InvalidAlgorithmError(message) {\n  this.name = 'InvalidAlgorithmError';\n  this.message = message;\n  this.stack = new Error().stack;\n}\n\nInvalidAlgorithmError.prototype = new Error(); ///--- Internal Functions\n\nfunction _pad(val) {\n  if (parseInt(val, 10) < 10) {\n    val = '0' + val;\n  }\n\n  return val;\n}\n\nfunction _rfc1123() {\n  var date = new Date();\n  var months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];\n  var days = ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'];\n  return days[date.getUTCDay()] + ', ' + _pad(date.getUTCDate()) + ' ' + months[date.getUTCMonth()] + ' ' + date.getUTCFullYear() + ' ' + _pad(date.getUTCHours()) + ':' + _pad(date.getUTCMinutes()) + ':' + _pad(date.getUTCSeconds()) + ' GMT';\n} ///--- Exported API\n\n\nmodule.exports = {\n  /**\n   * Adds an 'Authorization' header to an http.ClientRequest object.\n   *\n   * Note that this API will add a Date header if it's not already set. Any\n   * other headers in the options.headers array MUST be present, or this\n   * will throw.\n   *\n   * You shouldn't need to check the return type; it's just there if you want\n   * to be pedantic.\n   *\n   * @param {Object} request an instance of http.ClientRequest.\n   * @param {Object} options signing parameters object:\n   *                   - {String} keyId required.\n   *                   - {String} key required (either a PEM or HMAC key).\n   *                   - {Array} headers optional; defaults to ['date'].\n   *                   - {String} algorithm optional; defaults to 'rsa-sha256'.\n   *                   - {String} httpVersion optional; defaults to '1.1'.\n   * @return {Boolean} true if Authorization (and optionally Date) were added.\n   * @throws {TypeError} on bad parameter types (input).\n   * @throws {InvalidAlgorithmError} if algorithm was bad.\n   * @throws {MissingHeaderError} if a header to be signed was specified but\n   *                              was not present.\n   */\n  signRequest: function signRequest(request, options) {\n    assert.object(request, 'request');\n    assert.object(options, 'options');\n    assert.optionalString(options.algorithm, 'options.algorithm');\n    assert.string(options.keyId, 'options.keyId');\n    assert.optionalArrayOfString(options.headers, 'options.headers');\n    assert.optionalString(options.httpVersion, 'options.httpVersion');\n    if (!request.getHeader('Date')) request.setHeader('Date', _rfc1123());\n    if (!options.headers) options.headers = ['date'];\n    if (!options.algorithm) options.algorithm = 'rsa-sha256';\n    if (!options.httpVersion) options.httpVersion = '1.1';\n    options.algorithm = options.algorithm.toLowerCase();\n    if (!Algorithms[options.algorithm]) throw new InvalidAlgorithmError(options.algorithm + ' is not supported');\n    var i;\n    var stringToSign = '';\n\n    for (i = 0; i < options.headers.length; i++) {\n      if (typeof options.headers[i] !== 'string') throw new TypeError('options.headers must be an array of Strings');\n      var h = options.headers[i].toLowerCase();\n\n      if (h !== 'request-line') {\n        var value = request.getHeader(h);\n\n        if (!value) {\n          throw new MissingHeaderError(h + ' was not in the request');\n        }\n\n        stringToSign += h + ': ' + value;\n      } else {\n        stringToSign += request.method + ' ' + request.path + ' HTTP/' + options.httpVersion;\n      }\n\n      if (i + 1 < options.headers.length) stringToSign += '\\n';\n    }\n\n    var alg = options.algorithm.match(/(hmac|rsa)-(\\w+)/);\n    var signature;\n\n    if (alg[1] === 'hmac') {\n      var hmac = crypto.createHmac(alg[2].toUpperCase(), options.key);\n      hmac.update(stringToSign);\n      signature = hmac.digest('base64');\n    } else {\n      var signer = crypto.createSign(options.algorithm.toUpperCase());\n      signer.update(stringToSign);\n      signature = signer.sign(options.key, 'base64');\n    }\n\n    request.setHeader('Authorization', sprintf(Authorization, options.keyId, options.algorithm, options.headers.join(' '), signature));\n    return true;\n  }\n};","map":null,"metadata":{},"sourceType":"script"}