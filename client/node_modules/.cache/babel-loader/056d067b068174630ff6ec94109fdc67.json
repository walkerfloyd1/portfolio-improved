{"ast":null,"code":"/*\n * ctf.js\n *\n * Understand and parse all of the different JSON formats of CTF data and\n * translate that into a series of node-ctype friendly pieces. The reason for\n * the abstraction is to handle different changes in the file format.\n *\n * We have to be careful here that we don't end up using a name that is already\n * a built in type.\n */\nvar mod_assert = require('assert');\n\nvar ASSERT = mod_assert.ok;\nvar ctf_versions = ['1.0'];\nvar ctf_entries = ['integer', 'float', 'typedef', 'struct'];\nvar ctf_deftypes = ['int8_t', 'uint8_t', 'int16_t', 'uint16_t', 'int32_t', 'uint32_t', 'float', 'double'];\n\nfunction ctfParseInteger(entry, ctype) {\n  var name, sign, len, type;\n  name = entry['name'];\n  if (!('signed' in entry['integer'])) throw new Error('Malformed CTF JSON: integer missing ' + 'signed value');\n  if (!('length' in entry['integer'])) throw new Error('Malformed CTF JSON: integer missing ' + 'length value');\n  sign = entry['integer']['signed'];\n  len = entry['integer']['length'];\n  type = null;\n  if (sign && len == 1) type = 'int8_t';else if (len == 1) type = 'uint8_t';else if (sign && len == 2) type = 'int16_t';else if (len == 2) type = 'uint16_t';else if (sign && len == 4) type = 'int32_t';else if (len == 4) type = 'uint32_t';else if (sign && len == 8) type = 'int64_t';else if (len == 8) type = 'uint64_t';\n  if (type === null) throw new Error('Malformed CTF JSON: integer has ' + 'unsupported length and sign - ' + len + '/' + sign);\n  /*\n   * This means that this is the same as one of our built in types. If\n   * that's the case defining it would be an error. So instead of trying\n   * to typedef it, we'll return here.\n   */\n\n  if (name == type) return;\n\n  if (name == 'char') {\n    ASSERT(type == 'int8_t');\n    return;\n  }\n\n  ctype.typedef(name, type);\n}\n\nfunction ctfParseFloat(entry, ctype) {\n  var name, len;\n  name = entry['name'];\n  if (!('length' in entry['float'])) throw new Error('Malformed CTF JSON: float missing ' + 'length value');\n  len = entry['float']['length'];\n  if (len != 4 && len != 8) throw new Error('Malformed CTF JSON: float has invalid ' + 'length value');\n\n  if (len == 4) {\n    if (name == 'float') return;\n    ctype.typedef(name, 'float');\n  } else if (len == 8) {\n    if (name == 'double') return;\n    ctype.typedef(name, 'double');\n  }\n}\n\nfunction ctfParseTypedef(entry, ctype) {\n  var name, type, ii;\n  name = entry['name'];\n  if (typeof entry['typedef'] != 'string') throw new Error('Malformed CTF JSON: typedef value in not ' + 'a string');\n  type = entry['typedef'];\n  /*\n   * We need to ensure that we're not looking at type that's one of our\n   * built in types. Traditionally in C a uint32_t would be a typedef to\n   * some kind of integer. However, those size types are built ins.\n   */\n\n  for (ii = 0; ii < ctf_deftypes.length; ii++) {\n    if (name == ctf_deftypes[ii]) return;\n  }\n\n  ctype.typedef(name, type);\n}\n\nfunction ctfParseStruct(entry, ctype) {\n  var name, type, ii, val, index, member, push;\n  member = [];\n  if (!Array.isArray(entry['struct'])) throw new Error('Malformed CTF JSON: struct value is not ' + 'an array');\n\n  for (ii = 0; ii < entry['struct'].length; ii++) {\n    val = entry['struct'][ii];\n    if (!('name' in val)) throw new Error('Malformed CTF JSON: struct member ' + 'missing name');\n    if (!('type' in val)) throw new Error('Malformed CTF JSON: struct member ' + 'missing type');\n    if (typeof val['name'] != 'string') throw new Error('Malformed CTF JSON: struct member ' + 'name isn\\'t a string');\n    if (typeof val['type'] != 'string') throw new Error('Malformed CTF JSON: struct member ' + 'type isn\\'t a string');\n    /*\n     * CTF version 2 specifies array names as <type> [<num>] where\n     * as node-ctype does this as <type>[<num>].\n     */\n\n    name = val['name'];\n    type = val['type'];\n    index = type.indexOf(' [');\n\n    if (index != -1) {\n      type = type.substring(0, index) + type.substring(index + 1, type.length);\n    }\n\n    push = {};\n    push[name] = {\n      'type': type\n    };\n    member.push(push);\n  }\n\n  name = entry['name'];\n  ctype.typedef(name, member);\n}\n\nfunction ctfParseEntry(entry, ctype) {\n  var ii, found;\n  if (!('name' in entry)) throw new Error('Malformed CTF JSON: entry missing \"name\" ' + 'section');\n\n  for (ii = 0; ii < ctf_entries.length; ii++) {\n    if (ctf_entries[ii] in entry) found++;\n  }\n\n  if (found === 0) throw new Error('Malformed CTF JSON: found no entries');\n  if (found >= 2) throw new Error('Malformed CTF JSON: found more than one ' + 'entry');\n\n  if ('integer' in entry) {\n    ctfParseInteger(entry, ctype);\n    return;\n  }\n\n  if ('float' in entry) {\n    ctfParseFloat(entry, ctype);\n    return;\n  }\n\n  if ('typedef' in entry) {\n    ctfParseTypedef(entry, ctype);\n    return;\n  }\n\n  if ('struct' in entry) {\n    ctfParseStruct(entry, ctype);\n    return;\n  }\n\n  ASSERT(false, 'shouldn\\'t reach here');\n}\n\nfunction ctfParseJson(json, ctype) {\n  var version, ii;\n  ASSERT(json);\n  ASSERT(ctype);\n  if (!('metadata' in json)) throw new Error('Invalid CTF JSON: missing metadata section');\n  if (!('ctf2json_version' in json['metadata'])) throw new Error('Invalid CTF JSON: missing ctf2json_version');\n  version = json['metadata']['ctf2json_version'];\n\n  for (ii = 0; ii < ctf_versions.length; ii++) {\n    if (ctf_versions[ii] == version) break;\n  }\n\n  if (ii == ctf_versions.length) throw new Error('Unsuported ctf2json_version: ' + version);\n  if (!('data' in json)) throw new Error('Invalid CTF JSON: missing data section');\n  if (!Array.isArray(json['data'])) throw new Error('Malformed CTF JSON: data section is not ' + 'an array');\n\n  for (ii = 0; ii < json['data'].length; ii++) ctfParseEntry(json['data'][ii], ctype);\n}\n\nexports.ctfParseJson = ctfParseJson;","map":null,"metadata":{},"sourceType":"script"}